<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Monitoring Report</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.0.1/dist/chartjs-plugin-annotation.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-matrix@2.0.1/dist/chartjs-chart-matrix.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1e1e1e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        h1 {
            color: #14ffec;
            border-bottom: 2px solid #0d7377;
            padding-bottom: 10px;
        }
        h2 {
            color: #0d7377;
            margin-top: 30px;
        }
        .summary {
            background-color: #2a2a2a;
            border-left: 4px solid #0d7377;
            padding: 15px;
            margin: 20px 0;
            display: flex;
            gap: 40px;
        }
        .summary-item {
            flex: 1;
        }
        .summary-label {
            color: #888;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        .summary-value {
            color: #14ffec;
            font-size: 1.3em;
            font-weight: bold;
        }
        .chart-container {
            background-color: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            position: relative;
            height: 350px;
        }
        .chart-title {
            color: #14ffec;
            font-size: 1.1em;
            font-weight: bold;
            margin-bottom: 10px;
        }
        .chart-hint {
            color: #888;
            font-size: 0.85em;
            margin-bottom: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #2a2a2a;
        }
        th {
            background-color: #0d7377;
            color: #e0e0e0;
            padding: 12px;
            text-align: left;
            position: sticky;
            top: 0;
        }
        td {
            padding: 10px;
            border-bottom: 1px solid #3a3a3a;
        }
        tr:hover {
            background-color: #333;
        }
        .metric-name {
            color: #14ffec;
            font-weight: bold;
        }
        .value-min { color: #4ecdc4; }
        .value-max { color: #ff6b6b; }
        .value-avg { color: #ffd93d; }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #3a3a3a;
            text-align: center;
            color: #888;
            font-size: 0.9em;
        }
        h3 {
            color: #4ecdc4;
            margin-bottom: 15px;
            font-size: 1.2em;
        }
        
        /* Log event marker styles */
        .log-marker-critical { background-color: #dc143c !important; }
        .log-marker-error { background-color: #ff4444 !important; }
        .log-marker-warning { background-color: #ffa500 !important; }
        .log-marker-info { background-color: #2196f3 !important; }
        .log-marker-debug { background-color: #9e9e9e !important; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä System Monitoring Report - {{ source_name }}</h1>
        
        <div class="summary">
            <div class="summary-item">
                <div class="summary-label">Data Source</div>
                <div class="summary-value">{{ source_name }}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Retrieval Method</div>
                <div class="summary-value">{{ data_source_method }}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Start Time</div>
                <div class="summary-value">{{ start_time }}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Duration</div>
                <div class="summary-value">{{ duration }}</div>
            </div>
            <div class="summary-item">
                <div class="summary-label">Data Points</div>
                <div class="summary-value">{{ data_points }}</div>
            </div>
        </div>
        
        <script>
            // Hide GPU temp/power containers if no data
            window.addEventListener('DOMContentLoaded', () => {
                // chartData is defined in the main script block below
                // const chartData = JSON.parse('{{ chart_data_json }}');
                
                // Hide GPU temperature chart if all zeros
                if (!chartData.gpu.temp || chartData.gpu.temp.every(t => t === 0)) {
                    const tempContainer = document.getElementById('gpuTempContainer');
                    if (tempContainer) tempContainer.style.display = 'none';
                }
                
                // Hide GPU power chart if all zeros
                if (!chartData.gpu.power || chartData.gpu.power.every(p => p === 0)) {
                    const powerContainer = document.getElementById('gpuPowerContainer');
                    if (powerContainer) powerContainer.style.display = 'none';
                }
                
                // Hide swap chart if all zeros
                if (!chartData.memory.swap_percent || chartData.memory.swap_percent.every(s => s === 0)) {
                    const swapContainer = document.getElementById('swapContainer');
                    if (swapContainer) swapContainer.style.display = 'none';
                }
            });
        </script>
        
        <h2>üìà Interactive Time Series Charts</h2>
        <p class="chart-hint" style="color: #888; margin-bottom: 20px;">
            üí° <strong>Tip:</strong> Use mouse wheel to zoom, drag to pan, double-click to reset
        </p>
        
        <!-- CPU Charts Section -->
        <h3 style="color: #14ffec; margin-top: 30px;">üñ•Ô∏è CPU Metrics</h3>
        
        <div class="chart-container">
            <div class="chart-title">CPU Usage - Total (%)</div>
            <canvas id="cpuUsageChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">CPU Usage - Per Core (%)</div>
            <canvas id="cpuPerCoreChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">CPU Frequency - Average (MHz)</div>
            <canvas id="cpuFreqChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">CPU Frequency - Per Core (MHz)</div>
            <canvas id="cpuPerCoreFreqChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">üå°Ô∏è CPU Temperature (¬∞C)</div>
            <canvas id="cpuTempChart"></canvas>
        </div>
        
        <div class="chart-container" id="cpuPowerContainer">
            <div class="chart-title">‚ö° CPU Power Consumption (W)</div>
            <canvas id="cpuPowerChart"></canvas>
        </div>
        
        <!-- Tier 1 System Metrics Section -->
        <h3 id="tier1SectionHeader" style="color: #14ffec; margin-top: 30px; display: none;">üìä Advanced System Metrics (Tier 1)</h3>
        
        <div class="chart-container" id="tier1ContextSwitchesContainer" style="display: none;">
            <div class="chart-title">Context Switches (per second)</div>
            <canvas id="tier1ContextSwitchesChart"></canvas>
        </div>
        
        <div class="chart-container" id="tier1LoadAverageContainer" style="display: none;">
            <div class="chart-title">System Load Average</div>
            <canvas id="tier1LoadAverageChart"></canvas>
        </div>
        
        <div class="chart-container" id="tier1ProcessesContainer" style="display: none;">
            <div class="chart-title">Process Counts (Running / Blocked)</div>
            <canvas id="tier1ProcessesChart"></canvas>
        </div>
        
        <div class="chart-container" id="tier1IrqContainer" style="display: none;">
            <div class="chart-title">Per-Core IRQ% (Hardware Interrupts)</div>
            <canvas id="tier1IrqChart"></canvas>
        </div>
        
        <div class="chart-container" id="tier1SoftirqContainer" style="display: none;">
            <div class="chart-title">Per-Core SoftIRQ% (Software Interrupts)</div>
            <canvas id="tier1SoftirqChart"></canvas>
        </div>

        <div class="chart-container" id="tier1InterruptsContainer" style="display: none;">
            <div class="chart-title">Interrupt Distribution - Top Sources (interrupts/sec)</div>
            <canvas id="tier1InterruptsChart"></canvas>
        </div>

        <div class="chart-container" id="tier1InterruptsHeatmapContainer" style="display: none;">
            <div class="chart-title">Interrupt CPU Affinity Heatmap - Per-CPU Distribution</div>
            <canvas id="tier1InterruptsHeatmap"></canvas>
        </div>
        
        <!-- GPU Charts Section -->
        <h3 style="color: #14ffec; margin-top: 30px;">üéÆ GPU Metrics</h3>
        
        <div class="chart-container">
            <div class="chart-title">GPU Usage (%) & Frequency (MHz)</div>
            <canvas id="gpuUsageChart"></canvas>
        </div>
        <!-- GPU Memory chart removed: Integrated GPUs share system RAM, no separate memory tracking -->
        <!-- 
        <div class="chart-container">
            <div class="chart-title">GPU Memory (MB) & Utilization (%)</div>
            <canvas id="gpuMemoryChart"></canvas>
        </div>
        -->
        
        <div class="chart-container" id="gpuTempContainer">
            <div class="chart-title">üå°Ô∏è GPU Temperature (¬∞C)</div>
            <canvas id="gpuTempChart"></canvas>
        </div>
        
        <div class="chart-container" id="gpuPowerContainer">
            <div class="chart-title">‚ö° GPU Power Consumption (W)</div>
            <canvas id="gpuPowerChart"></canvas>
        </div>
        
        <!-- Memory Charts Section -->
        <h3 style="color: #14ffec; margin-top: 30px;">üß† Memory Metrics</h3>
        
        <div class="chart-container">
            <div class="chart-title">Memory Usage (%)</div>
            <canvas id="memoryChart"></canvas>
        </div>
        
        <div class="chart-container">
            <div class="chart-title">Memory Details (GB)</div>
            <canvas id="memoryDetailsChart"></canvas>
        </div>
        
        <div class="chart-container" id="swapContainer">
            <div class="chart-title">üíø Swap Usage (%)</div>
            <canvas id="swapChart"></canvas>
        </div>
        
        <!-- NPU Chart if available -->
        {{ npu_section }}
        
        <!-- Network I/O Chart if available -->
        {{ network_section }}
        
        <!-- Disk I/O Chart if available -->
        {{ disk_section }}
        
        <h2>üìä Statistics Summary</h2>
        <table>
            <thead>
                <tr>
                    <th>Metric</th>
                    <th>Minimum</th>
                    <th>Maximum</th>
                    <th>Average</th>
                    <th>Samples</th>
                </tr>
            </thead>
            <tbody>
                {{ stats_rows }}
            </tbody>
        </table>
        
        <div class="footer">
            Generated by Monitor Tool - Pro Edition<br>
            Report created: {{ report_time }}
        </div>
    </div>
    
    <script>
        const chartData = JSON.parse('{{ chart_data_json }}');
        
        // Helper function to create log event annotations
        function createLogAnnotations(logEvents, timestamps) {
            if (!logEvents || logEvents.length === 0) {
                console.log('No log events to annotate');
                return [];
            }
            
            console.log(`Creating annotations for ${logEvents.length} log events`);
            console.log(`Chart has ${timestamps.length} timestamps from ${timestamps[0]} to ${timestamps[timestamps.length-1]}`);
            
            const severityColors = {
                'critical': '#dc143c',  // Dark red (crimson)
                'error': '#ff4444',     // Bright red
                'warning': '#ffa500',   // Orange (optional to show)
                'info': '#2196f3',
                'debug': '#9e9e9e'
            };
            
            const annotations = [];
            
            for (const logEvent of logEvents) {
                // Find the closest timestamp index for this log event
                let closestIndex = 0;
                let minDiff = Math.abs(timestamps[0] - logEvent.timestamp);
                
                for (let i = 1; i < timestamps.length; i++) {
                    const diff = Math.abs(timestamps[i] - logEvent.timestamp);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closestIndex = i;
                    }
                }
                
                console.log(`Log event ${logEvent.severity} at timestamp ${logEvent.timestamp} -> index ${closestIndex} (chart time: ${timestamps[closestIndex]}, diff: ${minDiff}s)`);
                
                const annotation = {
                    type: 'line',
                    xMin: closestIndex,
                    xMax: closestIndex,
                    borderColor: severityColors[logEvent.severity] || '#9e9e9e',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    label: {
                        display: false,  // Hidden by default
                        content: `${logEvent.severity.toUpperCase()}: ${logEvent.message}`,
                        position: 'start',
                        backgroundColor: severityColors[logEvent.severity] || '#9e9e9e',
                        color: '#fff',
                        font: {
                            size: 11,
                            weight: 'bold'
                        },
                        padding: 4
                    },
                    enter({element}) {
                        element.label.options.display = true;  // Show on hover
                        return true;
                    },
                    leave({element}) {
                        element.label.options.display = false;  // Hide when not hovering
                        return true;
                    }
                };
                
                annotations.push(annotation);
            }
            
            console.log(`Total annotations created: ${annotations.length}`);
            return annotations;
        }
        
        // Create annotations from log events
        const logAnnotations = createLogAnnotations(chartData.log_events || [], chartData.timestamps);
        
        // Common chart configuration
        const commonOptions = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: true,
                    labels: { color: '#e0e0e0' }
                },
                annotation: {
                    annotations: logAnnotations
                },
                zoom: {
                    pan: {
                        enabled: true,
                        mode: 'x',
                    },
                    zoom: {
                        wheel: {
                            enabled: true,
                        },
                        pinch: {
                            enabled: true
                        },
                        mode: 'x',
                    }
                }
            },
            scales: {
                x: {
                    title: {
                        display: true,
                        text: 'Time',
                        color: '#e0e0e0'
                    },
                    ticks: { 
                        color: '#888',
                        maxRotation: 45,
                        minRotation: 45
                    },
                    grid: { color: '#3a3a3a' }
                },
                y: {
                    ticks: { color: '#888' },
                    grid: { color: '#3a3a3a' }
                }
            }
        };
        
        // CPU Usage (Total) Chart
        new Chart(document.getElementById('cpuUsageChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: [{
                    label: 'CPU Usage (Total)',
                    data: chartData.cpu.usage_total,
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Usage (%)', color: '#e0e0e0' },
                        min: 0,
                        max: 100
                    }
                }
            }
        });
        
        // CPU Usage Per-Core Chart
        const cpuCoreColors = ['#ff6b6b', '#ffd93d', '#4ecdc4', '#95e1d3', '#c589e8', '#ff9ff3', 
                               '#feca57', '#48dbfb', '#ff6348', '#1dd1a1', '#10ac84', '#ee5a6f'];
        const coreDatasets = [];
        for (let i = 0; i < chartData.cpu.max_cores; i++) {
            coreDatasets.push({
                label: `Core ${i}`,
                data: chartData.cpu.usage_per_core.map(cores => cores[i] || 0),
                borderColor: cpuCoreColors[i % cpuCoreColors.length],
                backgroundColor: 'transparent',
                borderWidth: 1.5,
                tension: 0.3,
                fill: false,
                hidden: i >= 4  // Hide cores 4+ by default, click legend to show
            });
        }
        new Chart(document.getElementById('cpuPerCoreChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: coreDatasets
            },
            options: {
                ...commonOptions,
                plugins: {
                    ...commonOptions.plugins,
                    legend: {
                        ...commonOptions.plugins.legend,
                        onClick: function(e, legendItem, legend) {
                            // Default Chart.js legend click behavior
                            const index = legendItem.datasetIndex;
                            const ci = legend.chart;
                            const meta = ci.getDatasetMeta(index);
                            meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;
                            ci.update();
                        }
                    }
                },
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Usage (%)', color: '#e0e0e0' },
                        min: 0,
                        max: 100
                    }
                }
            }
        });
        
        // CPU Average Frequency Chart
        new Chart(document.getElementById('cpuFreqChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: [{
                    label: 'CPU Frequency (Avg)',
                    data: chartData.cpu.freq_avg,
                    borderColor: '#ffd93d',
                    backgroundColor: 'rgba(255, 217, 61, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Frequency (MHz)', color: '#e0e0e0' }
                    }
                }
            }
        });
        
        // CPU Per-Core Frequency Chart
        const freqDatasets = [];
        for (let i = 0; i < chartData.cpu.max_cores; i++) {
            freqDatasets.push({
                label: `Core ${i}`,
                data: chartData.cpu.freq_per_core.map(cores => cores[i] || 0),
                borderColor: cpuCoreColors[i % cpuCoreColors.length],
                backgroundColor: 'transparent',
                borderWidth: 1.5,
                tension: 0.3,
                fill: false,
                hidden: i >= 4  // Hide cores 4+ by default
            });
        }
        new Chart(document.getElementById('cpuPerCoreFreqChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: freqDatasets
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Frequency (MHz)', color: '#e0e0e0' }
                    }
                }
            }
        });
        
        // CPU Temperature Chart
        const tempDatasets = [];
        const tempColors = ['#ff6348', '#ff9ff3', '#feca57', '#48dbfb', '#1dd1a1', '#10ac84'];
        for (let i = 0; i < chartData.cpu.max_temp_sensors; i++) {
            const sensorLabel = chartData.cpu.temps[0] && chartData.cpu.temps[0][i] ? chartData.cpu.temps[0][i].label : `Sensor ${i}`;
            // Keep Package/CPU temps visible, hide individual cores by default
            const isImportant = sensorLabel.toLowerCase().includes('package') || 
                               sensorLabel.toLowerCase().includes('cpu') ||
                               chartData.cpu.max_temp_sensors <= 2;  // Show all if only 1-2 sensors
            tempDatasets.push({
                label: sensorLabel,
                data: chartData.cpu.temps.map(sensors => sensors[i] ? sensors[i].current : 0),
                borderColor: tempColors[i % tempColors.length],
                backgroundColor: 'transparent',
                borderWidth: isImportant ? 2.5 : 1.5,  // Thicker line for important temps
                tension: 0.3,
                fill: false,
                hidden: !isImportant  // Hide individual core temps by default, show package/CPU
            });
        }
        new Chart(document.getElementById('cpuTempChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: tempDatasets
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Temperature (¬∞C)', color: '#e0e0e0' }
                    }
                }
            }
        });
        
        // CPU Power Chart
        if (chartData.cpu.power && chartData.cpu.power.some(p => p !== null && p > 0)) {
            document.getElementById('cpuPowerContainer').style.display = 'block';
            new Chart(document.getElementById('cpuPowerChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [{
                        label: 'CPU Power (W)',
                        data: chartData.cpu.power,
                        borderColor: '#ffd93d',
                        backgroundColor: 'rgba(255, 217, 61, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Power (W)', color: '#e0e0e0' }
                        }
                    }
                }
            });
        } else {
            document.getElementById('cpuPowerContainer').style.display = 'none';
        }
        
        // ============================================
        // Tier 1 System Metrics Charts
        // ============================================
        
        // Show Tier 1 section header if any Tier 1 data exists
        if (chartData.tier1) {
            document.getElementById('tier1SectionHeader').style.display = 'block';
        }
        
        // Context Switches Chart
        if (chartData.tier1 && chartData.tier1.context_switches && chartData.tier1.context_switches.length > 0) {
            document.getElementById('tier1ContextSwitchesContainer').style.display = 'block';
            new Chart(document.getElementById('tier1ContextSwitchesChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [{
                        label: 'Context Switches/sec',
                        data: chartData.tier1.context_switches,
                        borderColor: '#ff6384',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Context Switches/sec', color: '#e0e0e0' }
                        }
                    }
                }
            });
        }
        
        // Load Average Chart
        if (chartData.tier1 && chartData.tier1.load_avg_1m && chartData.tier1.load_avg_1m.length > 0) {
            document.getElementById('tier1LoadAverageContainer').style.display = 'block';
            new Chart(document.getElementById('tier1LoadAverageChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [
                        {
                            label: '1 minute',
                            data: chartData.tier1.load_avg_1m,
                            borderColor: '#ff6384',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: false
                        },
                        {
                            label: '5 minute',
                            data: chartData.tier1.load_avg_5m,
                            borderColor: '#36a2eb',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: false
                        },
                        {
                            label: '15 minute',
                            data: chartData.tier1.load_avg_15m,
                            borderColor: '#4bc0c0',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: false
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Load Average', color: '#e0e0e0' }
                        }
                    }
                }
            });
        }
        
        // Process Counts Chart
        if (chartData.tier1 && chartData.tier1.procs_running && chartData.tier1.procs_running.length > 0) {
            document.getElementById('tier1ProcessesContainer').style.display = 'block';
            new Chart(document.getElementById('tier1ProcessesChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [
                        {
                            label: 'Running',
                            data: chartData.tier1.procs_running,
                            borderColor: '#4bc0c0',
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        },
                        {
                            label: 'Blocked',
                            data: chartData.tier1.procs_blocked,
                            borderColor: '#ff9f40',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.3
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Process Count', color: '#e0e0e0' },
                            beginAtZero: true
                        }
                    }
                }
            });
        }
        
        // Per-Core IRQ% Chart
        if (chartData.tier1 && chartData.tier1.per_core_irq && chartData.tier1.per_core_irq.length > 0) {
            // Check if we have actual data (not all empty arrays)
            const hasIrqData = chartData.tier1.per_core_irq.some(arr => Array.isArray(arr) && arr.length > 0);
            if (hasIrqData) {
                document.getElementById('tier1IrqContainer').style.display = 'block';
                
                // Prepare datasets for each core
                // Find first non-empty array to get number of cores
                const firstNonEmpty = chartData.tier1.per_core_irq.find(arr => Array.isArray(arr) && arr.length > 0);
                const numCores = firstNonEmpty ? firstNonEmpty.length : 0;
                const irqDatasets = [];
            const colors = ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#ff9f40', '#9966ff', '#ff6384', '#c9cbcf'];
            
            for (let core = 0; core < numCores; core++) {
                irqDatasets.push({
                    label: `Core ${core}`,
                    data: chartData.tier1.per_core_irq.map(sample => sample[core] || 0),
                    borderColor: colors[core % colors.length],
                    borderWidth: 1.5,
                    tension: 0.3,
                    fill: false,
                    hidden: core >= 4  // Hide cores 4+ by default, like CPU frequency
                });
            }
            
            new Chart(document.getElementById('tier1IrqChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: irqDatasets
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'IRQ %', color: '#e0e0e0' },
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
            }
        }
        
        // Per-Core SoftIRQ% Chart
        if (chartData.tier1 && chartData.tier1.per_core_softirq && chartData.tier1.per_core_softirq.length > 0) {
            // Check if we have actual data (not all empty arrays)
            const hasSoftirqData = chartData.tier1.per_core_softirq.some(arr => Array.isArray(arr) && arr.length > 0);
            if (hasSoftirqData) {
                document.getElementById('tier1SoftirqContainer').style.display = 'block';
                
                // Prepare datasets for each core
                // Find first non-empty array to get number of cores
                const firstNonEmpty = chartData.tier1.per_core_softirq.find(arr => Array.isArray(arr) && arr.length > 0);
                const numCores = firstNonEmpty ? firstNonEmpty.length : 0;
                const softirqDatasets = [];
            const colors = ['#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', '#ff9f40', '#9966ff', '#ff6384', '#c9cbcf'];
            
            for (let core = 0; core < numCores; core++) {
                softirqDatasets.push({
                    label: `Core ${core}`,
                    data: chartData.tier1.per_core_softirq.map(sample => sample[core] || 0),
                    borderColor: colors[core % colors.length],
                    borderWidth: 1.5,
                    tension: 0.3,
                    fill: false,
                    hidden: core >= 4  // Hide cores 4+ by default, like CPU frequency
                });
            }
            
            new Chart(document.getElementById('tier1SoftirqChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: softirqDatasets
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'SoftIRQ %', color: '#e0e0e0' },
                            beginAtZero: true,
                            max: 100
                        }
                    }
                }
            });
            }
        }

        // Interrupt Distribution Chart
        if (chartData.tier1 && chartData.tier1.interrupts && Object.keys(chartData.tier1.interrupts).length > 0) {
            document.getElementById('tier1InterruptsContainer').style.display = 'block';
            
            // Sort interrupts by total count to show top sources
            const interruptEntries = Object.entries(chartData.tier1.interrupts);
            const topInterrupts = interruptEntries
                .sort((a, b) => {
                    const sumA = a[1].rates.reduce((acc, val) => acc + (val || 0), 0);
                    const sumB = b[1].rates.reduce((acc, val) => acc + (val || 0), 0);
                    return sumB - sumA;
                })
                .slice(0, 10);  // Show top 10 interrupt sources
            
            const interruptDatasets = topInterrupts.map((entry, idx) => {
                const [name, data] = entry;
                const colors = [
                    '#ff6384', '#36a2eb', '#ffce56', '#4bc0c0', 
                    '#ff9f40', '#9966ff', '#c9cbcf', '#ff6384',
                    '#8bc34a', '#ffc107'
                ];
                
                return {
                    label: `${name} (CPU${data.cpu})`,
                    data: data.rates,
                    borderColor: colors[idx % colors.length],
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false
                };
            });
            
            new Chart(document.getElementById('tier1InterruptsChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: interruptDatasets
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Interrupts/sec', color: '#e0e0e0' },
                            beginAtZero: true
                        }
                    },
                    plugins: {
                        ...commonOptions.plugins,
                        tooltip: {
                            ...commonOptions.plugins.tooltip,
                            callbacks: {
                                label: function(context) {
                                    return context.dataset.label + ': ' + 
                                           Math.round(context.parsed.y).toLocaleString() + ' interrupts/sec';
                                }
                            }
                        }
                    }
                }
            });
        }

        // Interrupt CPU Affinity Heatmap
        if (chartData.tier1 && chartData.tier1.interrupts && Object.keys(chartData.tier1.interrupts).length > 0) {
            document.getElementById('tier1InterruptsHeatmapContainer').style.display = 'block';
            
            // Get all interrupt sources and determine CPU count
            const interruptEntries = Object.entries(chartData.tier1.interrupts);
            let maxCpu = 0;
            interruptEntries.forEach(([name, data]) => {
                if (data.per_cpu && data.per_cpu.length > 0 && data.per_cpu[0]) {
                    // per_cpu is array of arrays; get length of inner array (CPU cores)
                    maxCpu = Math.max(maxCpu, data.per_cpu[0].length - 1);
                }
            });
            const cpuCount = maxCpu + 1;
            
            // Sort interrupts by total count
            const sortedInterrupts = interruptEntries
                .sort((a, b) => {
                    const sumA = a[1].rates.reduce((acc, val) => acc + (val || 0), 0);
                    const sumB = b[1].rates.reduce((acc, val) => acc + (val || 0), 0);
                    return sumB - sumA;
                })
                .slice(0, 10);  // Top 10 sources
            
            // Build heatmap data: average interrupts per CPU across all samples
            const heatmapData = [];
            sortedInterrupts.forEach(([name, data], yIndex) => {
                if (data.per_cpu && data.per_cpu.length > 0) {
                    // per_cpu is an array of arrays (one per sample timestamp)
                    // Get the last sample's per_cpu distribution
                    const latestPerCpu = data.per_cpu[data.per_cpu.length - 1];
                    for (let cpu = 0; cpu < cpuCount; cpu++) {
                        const value = latestPerCpu[cpu] || 0;
                        heatmapData.push({
                            x: `CPU${cpu}`,  // Use category label
                            y: name,          // Use interrupt name
                            v: value          // Interrupt count on this CPU
                        });
                    }
                }
            });
            
            // Find max value for color scaling
            const maxValue = Math.max(...heatmapData.map(d => d.v), 1);
            
            // Helper function for logarithmic color scaling
            function getHeatmapColor(value, maxVal) {
                if (!value || value === 0) return 'rgba(200, 200, 200, 0.2)'; // Grey for 0
                
                // Logarithmic scale
                // We map log(1)..log(maxVal) to 0..1
                const minLog = 0; // log(1)
                const maxLog = Math.log(maxVal || 1);
                const valLog = Math.log(value || 1);
                
                let ratio = 0;
                if (maxLog > minLog) {
                    ratio = (valLog - minLog) / (maxLog - minLog);
                }
                
                // Gradient: Blue (0) -> Green (0.5) -> Red (1.0)
                let r, g, b;
                if (ratio < 0.5) {
                    // Blue to Green
                    // ratio 0: 0,0,255
                    // ratio 0.5: 0,255,0
                    const localRatio = ratio * 2; 
                    r = 0;
                    g = Math.floor(255 * localRatio);
                    b = Math.floor(255 * (1 - localRatio) + 255 * localRatio); // Wait, Blue is 0,0,255. Green is 0,255,0.
                    // Blue component: 255 -> 0
                    b = Math.floor(255 * (1 - localRatio));
                } else {
                    // Green to Red
                    // ratio 0.5: 0,255,0
                    // ratio 1.0: 255,0,0
                    const localRatio = (ratio - 0.5) * 2;
                    r = Math.floor(255 * localRatio);
                    g = Math.floor(255 * (1 - localRatio));
                    b = 0;
                }
                
                return `rgba(${r}, ${g}, ${b}, 0.7)`;
            }

            new Chart(document.getElementById('tier1InterruptsHeatmap'), {
                type: 'matrix',
                data: {
                    datasets: [{
                        label: 'Interrupts',
                        data: heatmapData,
                        backgroundColor(context) {
                            if (!context.dataset || !context.dataset.data) return 'rgba(200, 200, 200, 0.2)';
                            const dataPoint = context.dataset.data[context.dataIndex];
                            if (!dataPoint || dataPoint.v === undefined) return 'rgba(200, 200, 200, 0.2)';
                            return getHeatmapColor(dataPoint.v, maxValue);
                        },
                        borderWidth: 1,
                        borderColor: '#333',
                        width: ({ chart }) => (chart.chartArea || {}).width / cpuCount - 1,
                        height: ({ chart }) => (chart.chartArea || {}).height / sortedInterrupts.length - 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title() { return ''; },
                                label(context) {
                                    const v = context.dataset.data[context.dataIndex];
                                    return `${v.y} on ${v.x}: ${v.v.toLocaleString()} interrupts`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'category',
                            position: 'bottom',
                            labels: Array.from({length: cpuCount}, (_, i) => `CPU${i}`),
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: { display: false },
                            title: { display: true, text: 'CPU Core', color: '#e0e0e0' }
                        },
                        y: {
                            type: 'category',
                            position: 'left',
                            labels: sortedInterrupts.map(item => item[0]),
                            ticks: {
                                color: '#e0e0e0'
                            },
                            grid: { display: false }
                        }
                    }
                }
            });
        }
        
        // GPU Usage & Frequency Chart (Dual Y-axis)
        new Chart(document.getElementById('gpuUsageChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: [{
                    label: 'GPU Usage (%)',
                    data: chartData.gpu.usage,
                    borderColor: '#4ecdc4',
                    backgroundColor: 'rgba(78, 205, 196, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    yAxisID: 'y'
                }, {
                    label: 'GPU Frequency (MHz)',
                    data: chartData.gpu.freq,
                    borderColor: '#ffd93d',
                    backgroundColor: 'rgba(255, 217, 61, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: false,
                    yAxisID: 'y1'
                }]
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        type: 'linear',
                        position: 'left',
                        title: { display: true, text: 'Usage (%)', color: '#4ecdc4' },
                        min: 0,
                        max: 100
                    },
                    y1: {
                        type: 'linear',
                        position: 'right',
                        title: { display: true, text: 'Frequency (MHz)', color: '#ffd93d' },
                        ticks: { color: '#888' },
                        grid: { 
                            drawOnChartArea: false,
                            color: '#3a3a3a'
                        }
                    }
                }
            }
        });
        
        // GPU Memory Chart - DISABLED for integrated GPUs
        // Integrated GPUs share system RAM and don't have separate memory tracking
        /*
        new Chart(document.getElementById('gpuMemoryChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: [{
                    label: 'GPU Memory Used',
                    data: chartData.gpu.memory_used,
                    borderColor: '#4ecdc4',
                    backgroundColor: 'rgba(78, 205, 196, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }, {
                    label: 'GPU Memory Utilization',
                    data: chartData.gpu.memory_util,
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true,
                    yAxisID: 'y1'
                }]
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Memory (MB)', color: '#e0e0e0' },
                        position: 'left'
                    },
                    y1: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Utilization (%)', color: '#e0e0e0' },
                        position: 'right',
                        min: 0,
                        max: 100,
                        grid: { drawOnChartArea: false }
                    }
                }
            }
        });
        */
        
        // GPU Temperature Chart
        if (chartData.gpu.temp && chartData.gpu.temp.some(t => t > 0)) {
            new Chart(document.getElementById('gpuTempChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [{
                        label: 'GPU Temperature',
                        data: chartData.gpu.temp,
                        borderColor: '#ff6348',
                        backgroundColor: 'rgba(255, 99, 72, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Temperature (¬∞C)', color: '#e0e0e0' }
                        }
                    }
                }
            });
        }
        
        // GPU Power Chart
        if (chartData.gpu.power && chartData.gpu.power.some(p => p > 0)) {
            new Chart(document.getElementById('gpuPowerChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [{
                        label: 'GPU Power',
                        data: chartData.gpu.power,
                        borderColor: '#feca57',
                        backgroundColor: 'rgba(254, 202, 87, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Power (W)', color: '#e0e0e0' }
                        }
                    }
                }
            });
        }
        
        // Memory Usage Chart
        new Chart(document.getElementById('memoryChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: [{
                    label: 'Memory Usage %',
                    data: chartData.memory.percent,
                    borderColor: '#a8e6cf',
                    backgroundColor: 'rgba(168, 230, 207, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Usage (%)', color: '#e0e0e0' },
                        min: 0,
                        max: 100
                    }
                }
            }
        });
        
        // Memory Details Chart (Used/Available)
        new Chart(document.getElementById('memoryDetailsChart'), {
            type: 'line',
            data: {
                labels: chartData.timestamps,
                datasets: [{
                    label: 'Memory Used',
                    data: chartData.memory.used,
                    borderColor: '#ff6b6b',
                    backgroundColor: 'rgba(255, 107, 107, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }, {
                    label: 'Memory Available',
                    data: chartData.memory.available,
                    borderColor: '#4ecdc4',
                    backgroundColor: 'rgba(78, 205, 196, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    fill: true
                }]
            },
            options: {
                ...commonOptions,
                scales: {
                    ...commonOptions.scales,
                    y: {
                        ...commonOptions.scales.y,
                        title: { display: true, text: 'Memory (GB)', color: '#e0e0e0' }
                    }
                }
            }
        });
        
        // Swap Usage Chart
        if (chartData.memory.swap_percent && chartData.memory.swap_percent.some(s => s > 0)) {
            new Chart(document.getElementById('swapChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [{
                        label: 'Swap Usage',
                        data: chartData.memory.swap_percent,
                        borderColor: '#c589e8',
                        backgroundColor: 'rgba(197, 137, 232, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Usage (%)', color: '#e0e0e0' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }
        
        // NPU Usage Chart (if available)
        if (chartData.npu && chartData.npu.usage && chartData.npu.usage.length > 0) {
            new Chart(document.getElementById('npuUsageChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [{
                        label: 'NPU Usage',
                        data: chartData.npu.usage,
                        borderColor: '#c589e8',
                        backgroundColor: 'rgba(197, 137, 232, 0.1)',
                        borderWidth: 2,
                        tension: 0.3,
                        fill: true
                    }]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Usage (%)', color: '#e0e0e0' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }
        
        // Network I/O Chart (if available)
        if (chartData.network && (chartData.network.upload || chartData.network.download)) {
            new Chart(document.getElementById('networkChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [
                        {
                            label: 'Upload',
                            data: chartData.network.upload,
                            borderColor: '#3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'Download',
                            data: chartData.network.download,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.1)',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Speed (MB/s)', color: '#e0e0e0' },
                            min: 0
                        }
                    }
                }
            });
        }
        
        // Disk I/O Chart (if available)
        if (chartData.disk && (chartData.disk.read || chartData.disk.write)) {
            new Chart(document.getElementById('diskChart'), {
                type: 'line',
                data: {
                    labels: chartData.timestamps,
                    datasets: [
                        {
                            label: 'Read',
                            data: chartData.disk.read,
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.1)',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true
                        },
                        {
                            label: 'Write',
                            data: chartData.disk.write,
                            borderColor: '#ef4444',
                            backgroundColor: 'rgba(239, 68, 68, 0.1)',
                            borderWidth: 2,
                            tension: 0.3,
                            fill: true
                        }
                    ]
                },
                options: {
                    ...commonOptions,
                    scales: {
                        ...commonOptions.scales,
                        y: {
                            ...commonOptions.scales.y,
                            title: { display: true, text: 'Speed (MB/s)', color: '#e0e0e0' },
                            min: 0
                        }
                    }
                }
            });
        }
        
        // Add double-click to reset zoom for all charts
        document.querySelectorAll('canvas').forEach(canvas => {
            canvas.addEventListener('dblclick', function() {
                const chart = Chart.getChart(canvas);
                if (chart && chart.resetZoom) {
                    chart.resetZoom();
                }
            });
        });
    </script>
</body>
</html>
